dec <- 0
for(i in 1:length(binVector)){
dec <- dec + (strtoi(binVector[i]) * (2**powerSeq[i]))
}
}
return(as.character(dec))
}
}
bin2dec(c('111','111'))
bin2dec(c('111'))
bin2dec <- function(bin){
# if(length(bin) > 1){
#   stop('bin2dec function only accepts a single number')
# }
if(stringr::str_count(bin,'1')+stringr::str_count(bin,'0') != nchar(bin)){
stop(paste0(bin,' contains non-binary digits or characters'))
}
binVector <- stringr::str_split(bin,"",simplify = F)[[1]]
# https://stackoverflow.com/questions/24009982/remove-zeros-in-the-start-and-end-of-a-vector
if(min(which(binVector != 0)) == Inf){
return('0')
}else{
binVector <- binVector[min(which(binVector != 0)):length(binVector)] # remove leading zero's
if(length(binVector) > 54){
stop(paste0('Binary number is too large for this package, sorry!(',length(binVector),'bit, max is 54bit)'))
}else{
powerSeq <- seq(nchar(bin)-1,0)
dec <- 0
for(i in 1:length(binVector)){
dec <- dec + (strtoi(binVector[i]) * (2**powerSeq[i]))
}
}
return(as.character(dec))
}
}
bin2dec(c('111'))
bin2dec(c('111','111'))
bin2dec <- function(bin){
if(length(bin) > 1){
stop('bin2dec function only accepts a single number')
}
if(stringr::str_count(bin,'1')+stringr::str_count(bin,'0') != nchar(bin)){
stop(paste0(bin,' contains non-binary digits or characters'))
}
binVector <- stringr::str_split(bin,"",simplify = F)[[1]]
# https://stackoverflow.com/questions/24009982/remove-zeros-in-the-start-and-end-of-a-vector
if(min(which(binVector != 0)) == Inf){
return('0')
}else{
binVector <- binVector[min(which(binVector != 0)):length(binVector)] # remove leading zero's
if(length(binVector) > 54){
stop(paste0('Binary number is too large for this package, sorry!(',length(binVector),'bit, max is 54bit)'))
}else{
powerSeq <- seq(nchar(bin)-1,0)
dec <- 0
for(i in 1:length(binVector)){
dec <- dec + (strtoi(binVector[i]) * (2**powerSeq[i]))
}
}
return(as.character(dec))
}
}
bin2dec(c('111','111'))
bin2dec(c('111'))
bin2dec(c('1112'))
bin2dec(c('000'))
bin2dec(c('0000000000000000'))
hexVector <- stringr::str_split('40000000000001','',simplify = F)[[1]]
length(hexVector) > 14 | (length(hexVector) == 14 & hexVector[1] >= 4 & hexVector[14] > 0)
hexVector <- stringr::str_split('40000000000000','',simplify = F)[[1]]
length(hexVector) > 14 | (length(hexVector) == 14 & hexVector[1] >= 4 & hexVector[14] > 0)
hexVector <- stringr::str_split('4000000000000000','',simplify = F)[[1]]
length(hexVector) > 14 | (length(hexVector) == 14 & hexVector[1] >= 4 & hexVector[14] > 0)
hexVector <- stringr::str_split('400000000000000','',simplify = F)[[1]]
length(hexVector) > 14 | (length(hexVector) == 14 & hexVector[1] >= 4 & hexVector[14] > 0)
hexVector <- stringr::str_split('40000000000000','',simplify = F)[[1]]
length(hexVector) > 14 | (length(hexVector) == 14 & hexVector[1] >= 4 & hexVector[14] > 0)
hexVector <- stringr::str_split('50000000000000','',simplify = F)[[1]]
length(hexVector) > 14 | (length(hexVector) == 14 & hexVector[1] >= 4 & hexVector[14] > 0)
sum(c('1','1'))
sum(as.numeric(c('1','1')))
length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector) > 4))
hexVector <- stringr::str_split('41000000000000','',simplify = F)[[1]]
length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector) > 4))
hex2dec <- function(hex){
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
if(length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector) > 4))){
stop(paste0(hex,' is too large for this package, sorry! (max = 40000000000000)'))
}else{
pow <- (length(hex)-1):0
dec <- 0
for(x in 1:length(hex)){
dec <- dec + (strtoi(hex[x],16)*(16**pow[x]))
}
}
return(dec)
}
hex2dec <- function(hex){
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
if(length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector) > 4))){
stop(paste0(hex,' is too large for this package, sorry! (max = 40000000000000)'))
}else{
pow <- (length(hex)-1):0
dec <- 0
for(x in 1:length(hex)){
dec <- dec + (strtoi(hex[x],16)*(16**pow[x]))
}
}
return(dec)
}
hex2dec('40000000000000')
hex2dec('4000000000000')
hex2dec('400000000000')
hex2dec('40000000000')
hex2dec('4000000000')
hex2dec('400000000')
hex2dec('40000000')
hex2dec('50000000')
hex2dec('60000000')
hex2dec('70000000')
hex2dec('80000000')
hex2dec('70000000')
hex2dec('7F000000')
hex2dec('75000000')
hex2dec('77000000')
hex2dec('7A000000')
hex2dec('7a000000')
hex2dec('700000a')
hex2dec('700000A')
hex2dec('A')
hex2dec <- function(hex){
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
if(length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector) > 4))){
stop(paste0(hex,' is too large for this package, sorry! (max = 40000000000000)'))
}else{
pow <- (length(hexVector)-1):0
dec <- 0
for(x in 1:length(hexVector)){
dec <- dec + (strtoi(hexVector[x],16)*(16**pow[x]))
}
}
return(dec)
}
hex2dec('A')
library(rISO11784)
hex <- "ABCD"
stringr::str_split(hex,'',simplify = F)[[1]]
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector) > 4))
length(hexVector) > 14
length(hexVector) == 14
sum(as.numeric(hexVector) > 4)
sum(1,1,1)
sum(c(1,1,1))
sum(c(1,1,1,A))
sum(c(1,1,1,'A'))
sum(c(1,1,1,'A'),na.rm = T)
hex2dec <- function(hex){
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
if(length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector) > 4,na.rm = T))){
stop(paste0(hex,' is too large for this package, sorry! (max = 40000000000000)'))
}else{
pow <- (length(hexVector)-1):0
dec <- 0
for(x in 1:length(hexVector)){
dec <- dec + (strtoi(hexVector[x],16)*(16**pow[x]))
}
}
return(dec)
}
hex2dec('A')
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
sum(as.numeric(hexVector) > 4,na.rm = T)
hex
sum(as.numeric(hexVector) > 4,na.rm = T)
hex2dec <- function(hex){
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
if(length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector) > 4,na.rm = T))){
stop(paste0(hex,' is too large for this package, sorry! (max = 40000000000000)'))
}else{
pow <- (length(hexVector)-1):0
dec <- 0
for(x in 1:length(hexVector)){
dec <- dec + (strtoi(hexVector[x],16)*(16**pow[x]))
}
}
return(dec)
}
hex2dec('ABCD')
hex2dec('ABCDE')
hex2dec('ABCDEF')
hex2dec('ABCDEFG')
hex2dec('ABCDEF1')
hex2dec('ABCDEF2')
hex2dec('ABCDEF23')
hex2dec('ABCDEF24')
hex2dec('ABCDEF25')
.Machine$integer.max
hex2dec('ABCDEF26')
hex2dec('ABCDEF36')
hex2dec('FBCDEF36')
hex2dec <- function(hex){
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
if(length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector) > 4,na.rm = T))){
stop(paste0(hex,' is too large for this package, sorry! (max = 40000000000000)'))
}else{
pow <- (length(hexVector)-1):0
dec <- 0
for(x in 1:length(hexVector)){
dec <- dec + as.numeric((strtoi(hexVector[x],16)*(16**pow[x])))
}
}
return(dec)
}
hex2dec('400000000000000000')
hex2dec('40000000000000000')
hex2dec('4000000000000000')
hex2dec('400000000000000')
hex2dec('40000000000000')
hex2dec('40000000000001')
hex <- '40000000000001'
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
length(hexVector) > 14
length(hexVector) == 14
sum(as.numeric(hexVector) > 4,na.rm = T)
hexVector
as.numeric(hexVector)
sum(as.numeric(hexVector))
sum(as.numeric(hexVector)) > 4
sum(as.numeric(hexVector),na.rm = T) > 4
sum(as.numeric(hexVector),na.rm = T) > 4
hex2dec <- function(hex){
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
if(length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector),na.rm = T) > 4)){
stop(paste0(hex,' is too large for this package, sorry! (max = 40000000000000)'))
}else{
pow <- (length(hexVector)-1):0
dec <- 0
for(x in 1:length(hexVector)){
dec <- dec + as.numeric((strtoi(hexVector[x],16)*(16**pow[x])))
}
}
return(dec)
}
hex2dec('ABCD')
hex2dec('40000000000001')
hex2dec('40000000000000')
install.packages('knitr')
library(rISO11784)
ISO64bitLeftToISODecimal <- function(hex){
# function to convert 64 bit ISO in hex format to ISO decimal format
# INPUT: single 64 bit hexadecimal number as string
##  ISO64bitl <- "^8000[:xdigit:]{12}$" # 64 bits and Animal ID bits on the left
# OUTPUT: single ISO decimal number as string
out <- c()
for(i in hex){
# part the hex string into manufacturer chunk (10 bits following the left most 16) and animal ID (the right most 38 bits)
manufacturer <- bin2dec(stringr::str_sub(hex2bin(stringr::str_sub(i,5,7)),1,10))
animalID <- stringr::str_pad(bin2dec(stringr::str_sub(hex2bin(stringr::str_sub(i,7,16)),3,40)),
width = 12,
pad = "0",
side = 'left')
out <- append(out,paste0(manufacturer,animalID))
}
return(out)
}
ISO64bitLeftToISODecimal(c('8000ABCDEF123456'))
#' Base Converters
#' These functions are used by the main ISO11784 converters to switch between bases 2, 10 and 16
#' Hexadecimal to Decimal converter
#' @param hex A single hexadecimal number as a string. Max '40000000000000'
#' @return A single decimal number as a string
#' @export
#' @examples
#' hex2dec('ABC123')
hex2dec <- function(hex){
if(length(hex) > 1){
stop('hex2dec function only accepts a single number')
}
hexVector <- stringr::str_split(hex,'',simplify = F)[[1]]
if(length(hexVector) > 14 | (length(hexVector) == 14 & sum(as.numeric(hexVector),na.rm = T) > 4)){
stop(paste0(hex,' is too large for this package, sorry! (max = "40000000000000")'))
}else{
pow <- (length(hexVector)-1):0
dec <- 0
for(x in 1:length(hexVector)){
dec <- dec + as.numeric((strtoi(hexVector[x],16)*(16**pow[x])))
}
}
return(dec)
}
#' Binary to Decimal converter
#' Will not work on binary numbers longer than 54bits. R integer maxes out at .Machine$integer.max, but
#' R will sum up to 18014398509481984, or 54bits, as long as it is not stored as an integer object.
#' @param bin A single binary number as a string with nchar(bin) <= 54
#' @return A single decimal number as a string
#' @export
#' @examples
#' bin2dec('1001100')
bin2dec <- function(bin){
if(length(bin) > 1){
stop('bin2dec function only accepts a single number')
}
if(stringr::str_count(bin,'1')+stringr::str_count(bin,'0') != nchar(bin)){
stop(paste0(bin,' contains non-binary digits or characters'))
}
binVector <- stringr::str_split(bin,"",simplify = F)[[1]]
# https://stackoverflow.com/questions/24009982/remove-zeros-in-the-start-and-end-of-a-vector
if(min(which(binVector != 0)) == Inf){
return('0')
}else{
binVector <- binVector[min(which(binVector != 0)):length(binVector)] # remove leading zero's
if(length(binVector) > 54){
stop(paste0('Binary number is too large for this package, sorry!(',length(binVector),'bit, max is 54bit)'))
}else{
powerSeq <- seq(nchar(bin)-1,0)
dec <- 0
for(i in 1:length(binVector)){
dec <- dec + (strtoi(binVector[i]) * (2**powerSeq[i]))
}
}
return(as.character(dec))
}
}
#' Decimal to Binary converter
#' @param dec A single decimal number as a string
#' @return A single binary number as a string
#' @export
#' @examples
#' dec2bin('1234')
dec2bin <- function(dec){
dec <- as.numeric(dec)
bin <- c() # initialise empty vector to capture binary characters
while(dec != 0){
bin <- append(bin,dec%%2,after = 0)
dec <- dec%/%2
}
return(paste0(bin,collapse = ""))
}
#' Decimal to Hexadecimal converter
#' @param dec A single decimal number as a string
#' @return A single hexadecimal number as a string
#' @export
#' @examples
#' dec2hex('1234')
dec2hex <- function(dec){
dec <- as.numeric(dec)
hex <- c() # initialise empty vector to capture hex characters
while(dec != 0){
hex <- append(hex, as.character(as.hexmode(dec%%16)),after = 0)
dec <- dec%/%16
}
return(paste0(hex,collapse = ""))
}
#' Hexadecimal to Binary converter
#' This is simply a wrapper for dec2bin and hex2dec
#' @param hex A single hexadecimal number as a string
#' @return A single binary number as a string
#' @export
#' @examples
#' hex2bin('ABC123')
hex2bin <- function(hex){
out <- stringr::str_pad(dec2bin(hex2dec(hex)),width = nchar(hex)*4,pad = "0",side = 'left')
return(out)
}
#' Binary to Hexadecimal converter
#' @param bin A single binary number as a string
#' @return A single hexadecimal number as a string
#' @export
#' @examples
#' bin2hex('1001101')
bin2hex <- function(bin){
binPadded <- stringr::str_pad(string = bin,
width = nchar(bin)+nchar(bin)%%4,
side = 'left',
pad = '0') # make sure binary string is divisible by 4
binClustered <- stringi::stri_sub(binPadded,
seq(1,nchar(binPadded),by=4),
length=4) # convert to nibbles (4 bit chunks)
dec <- strtoi(binClustered,2)
hex <- as.hexmode(dec)
return(paste0(hex,collapse = ""))
}
#' Main functions for converting from ISO11784 15 Digit Decimal to other formats
#' These are wrappers for the functions in baseConverters.R
#'
#'
ISOdecimalToISOdothex <- function(dec){
out <- c()
for(i in dec){
# convert the input integer to hexadecimal ISO format ABC.1234567ABC
decLeft <- as.numeric(stringr::str_sub(i,1,3)) # split the input value to 3/12
decRight <- as.numeric(stringr::str_sub(i,4,15)) # split the input value to 3/12
# calculations LEFT
hexLeft <- dec2hex(decLeft)
# calculations RIGHT
hexRight <- dec2hex(decRight)
# Leading zero's are removed in this process and need added back on
leadingZero <- paste0(rep('0',10-stringr::str_length(hexRight)),collapse = '')
# return finished hexadecimal string
out <- append(out,stringr::str_to_upper(paste0(hexLeft,'.',leadingZero,hexRight)))
}
return(out)
}
ISODecimalToISO64bitLeft <- function(dec){
# function to convert ISO decimal format to 64 bit ISO in hex format (left hand LSB variant)
# INPUT: single ISO decimal number as string
##  ISO64bitl <- "^8000[:xdigit:]{12}$" # 64 bits and LSB on the left
# OUTPUT: single 64 bit hexadecimal number as string
out <- c()
for(i in dec){
manufacturer <- stringr::str_pad(dec2bin(stringr::str_sub(i,1,3)),width = 10,pad = "0",side = 'left')
animalID <- stringr::str_pad(dec2bin(stringr::str_sub(i,4,15)),width = 38,pad = "0",side = 'left')
ISO64bitLeft <- paste0('1000000000000000',manufacturer,animalID)
out <- append(out,stringr::str_to_upper(bin2hex(ISO64bitLeft)))
}
return(out)
}
ISODecimalToISO64bitRight <- function(dec){
# function to convert ISO decimal format to 64 bit ISO in hex format (left hand LSB variant)
# INPUT: single ISO decimal number as string
##  ISO64bitr <- "^[:xdigit:]{12}0001$" # 64 bits and LSB on the right
# OUTPUT: single 64 bit hexadecimal number as string
out <- c()
for(i in dec){
manufacturer <- stringr::str_pad(dec2bin(stringr::str_sub(i,1,3)),width = 10,pad = "0",side = 'left')
animalID <- stringr::str_pad(dec2bin(stringr::str_sub(i,4,15)),width = 38,pad = "0",side = 'left')
ISO64bitLeft <- paste0('1000000000000000',manufacturer,animalID)
ISO64bitRight <- stringi::stri_reverse(ISO64bitLeft)
out <- append(out,stringr::str_to_upper(bin2hex(ISO64bitRight)))
}
return(out)
}
#' Main functions for converting from other formats TO ISO11784 15 Digit Decimal
#' These are wrappers for the functions in baseConverters.R
#'
#'
#' ISO 11784 Dot Hexadecimal format To ISO11784 15 Digit Decimal
#' @param hex A vector of Dot Hexadecimal format strings.
#' @return A vector of ISO11784 15 Digit Decimal format strings.
#' @export
#' @examples
#' ISOdothexToISOdecimal(c('3DD.ABC4567890'))
ISOdothexToISOdecimal <- function(hex){
out <- c()
for(i in hex){
# extract manufacturer (left) and animal id (right) components
hexLeft <- stringr::str_split(i,'\\.',simplify = T)[1]
hexRight <- stringr::str_split(i,'\\.',simplify = T)[2]
# calculations LEFT
decLeft <- hex2dec(hexLeft)
# calculations RIGHT
decRight <- hex2dec(hexRight)
# Leading zero's are removed in this process and need added back on
# only required for right hand component
decRight <- stringr::str_pad(string = decRight,width = 12, side = 'left',pad = '0')
out <- append(out,paste0(decLeft,decRight))
}
return(out)
}
#' ISO 11784 Raw Hexadecimal format, animal ID on the left, To ISO11784 15 Digit Decimal
#' @param hex A vector of Raw Hexadecimal format strings.
#' @return A vector of ISO11784 15 Digit Decimal format strings.
#' @export
#' @examples
#' ISO64bitLeftToISODecimal(c('8000ABCDEF123456'))
ISO64bitLeftToISODecimal <- function(hex){
# function to convert 64 bit ISO in hex format to ISO decimal format
# INPUT: single 64 bit hexadecimal number as string
##  ISO64bitl <- "^8000[:xdigit:]{12}$" # 64 bits and Animal ID bits on the left
# OUTPUT: single ISO decimal number as string
out <- c()
for(i in hex){
# part the hex string into manufacturer chunk (10 bits following the left most 16) and animal ID (the right most 38 bits)
manufacturer <- bin2dec(stringr::str_sub(hex2bin(stringr::str_sub(i,5,7)),1,10))
animalID <- stringr::str_pad(bin2dec(stringr::str_sub(hex2bin(stringr::str_sub(i,7,16)),3,40)),
width = 12,
pad = "0",
side = 'left')
out <- append(out,paste0(manufacturer,animalID))
}
return(out)
}
ISO64bitRightToISODecimal <- function(hex){
# function to convert 64 bit ISO in hex format to ISO decimal format
# INPUT: single 64 bit hexadecimal number as string
##  ISO64bitr <- "^[:xdigit:]{12}0001$" # 64 bits Animal ID bits on the right
# OUTPUT: single ISO decimal number as string
out <- c()
for(i in hex){
# part the hex string into manufacturer chunk (10 bits following the right most 16) and animal ID (the left most 38 bits)
manufacturer <- bin2dec(stringi::stri_reverse(stringr::str_sub(hex2bin(stringr::str_sub(i,10,12)),3,12)))
animalID <- stringr::str_pad(bin2dec(stringi::stri_reverse(stringr::str_sub(hex2bin(stringr::str_sub(i,1,10)),1,38))),
width = 12,
pad = "0",
side = 'left')
out <- append(out,paste0(manufacturer,animalID))
}
return(out)
}
ISO64bitLeftToISODecimal(c('8000ABCDEF123456'))
test <- '1234'
test
test <- c('1234')
test
test <- c('1234','1234')
test
hex2dec(test)
ISOdothexToISOdecimal(c('3DD.ABC4567890'))
library(rISO11784)
library(ISO11784RTools)
library(ISO11784RTools)
